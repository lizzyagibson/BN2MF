---
title: "Simulate Data Generating Process"
author: "Lizzy Gibson"
date: "7/09/2019"
output: 
  html_document:
    toc: TRUE
    toc_float: TRUE
---

```{r setup, include=FALSE}
options(scipen = 999)
library(MNdata) # my data
library(reshape2) # melt
library(gridExtra) # gridarrange
library(bindata) # multivariate binomial dist
library(NMF) # rmatrix
library(MASS) # mvrnorm
library(tidyverse)
library(R.matlab)
```

Simulate dataset with 1000 individuals and 50 chemicals to approx DATA GENERATING PROCESS of Mothers and Newborns cohort data.

* 22 pcbs, 11 pbdes, 9 phthalates, 8 phenols

<div class = "row">
  
<div class = "col-md-3">
* PCBs (22):
    * pcb28
    * pcb66
    * pcb74
    * pcb99
    * pcb105
    * pcb118
    * pcb138_158
    * pcb146
    * pcb153
    * pcb156
    * pcb167
    * pcb170
    * pcb178
    * pcb183
    * pcb187
    * pcb180
    * pcb189
    * pcb194
    * pcb196_203
    * pcb199
    * pcb206
    * pcb209
</div>
  
<div class = "col-md-3">
* PBDEs (11):
    * BDE17
    * BDE28
    * BDE47
    * BDE66
    * BDE85
    * BDE99
    * BDE100
    * BDE153
    * BDE154
    * BDE183
    * BDE209
</div>
  
<div class = "col-md-3">
* Phthalates (9):
    * MECPP
    * MEHHP
    * MEOHP
    * MCPP
    * MIBP
    * MBP
    * MBZP
    * MEP
    * MEHP
* Phenols (8):
    * dcp_24
    * dcp_25
    * b_pb
    * bp_3
    * m_pb
    * p_pb
    * tcs
    * bpa
</div>
</div>

## 1: Distinct Patterns

### Simulate Patterns

Generate 4 non-negative vectors of length 50 “by hand” — vectors should be overlapping a bit, and at this stage don’t have to look too much like pollution. just make 20 (of 50) elements 1 and the rest 0.

Pattern matrix is 4*50, patterns by chemicals.

```{r}
## Construct a matrix for 4 TRUE exposure patterns
set.seed(1988)
patterns_dist <- rbind(c(rep(1, 22), rep(0, 28)),
                       c(rep(0, 22), rep(1, 11), rep(0, 17)),
                       c(rep(0, 33), rep(1, 9), rep(0, 8)),
                       c(rep(0, 42), rep(1, 8)))
```

```{r}
patterns_dist %>% as_tibble() %>% 
  mutate(Pattern = 1:4) %>% select(Pattern, everything()) %>% 
  gather(key = Chemicals, value = Loadings, -Pattern) %>%
  mutate(Chemicals = fct_inorder(Chemicals)) %>% 
  ggplot(aes(x = Chemicals, y = Loadings)) + geom_col() +
  facet_wrap(.~Pattern) + theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "bottom",
        strip.background = element_blank())
```

### Simulate Individual Scores

Generate random scores indicating the presence of each vector for each observation from a gamma distribution.

```{r}
hist(rgamma(500, shape = 1))

scores_dist <- matrix(nrow = 1000, ncol = 4)

set.seed(1988)
for (i in 1:nrow(scores_dist)) {
  scores_dist[i,] <- rgamma(4, shape = 1) # gamma dist are INDEPENDENT
}

head(scores_dist)
cor(scores_dist)
```

### Simulate Chemical Exposures

Multiple scores and vectors, and add to get the mixture.

```{r}
chem_dist <- scores_dist %*% patterns_dist

summary(chem_dist)
```

### Simulate Noise

Noise is harder - if your scores are big enough just use a normal distribution to make sure things “work” and we can fancy it up from there.

```{r}
noise <- list(mean=0, sd=1)
set.seed(1988)
chem_dist <- pmax(chem_dist + rmatrix(chem_dist, dist=rnorm, mean=noise$mean, sd=noise$sd), 0)	
head(chem_dist[,1:10])
```  

### Visualize

```{r, echo = FALSE, fig.height = 7}
chem_dist <- chem_dist %>% 
  as_tibble(.) %>% 
  rename(pcb28 = 1
    , pcb66 = 2
    , pcb74 = 3
    , pcb99 = 4
    , pcb105 = 5
    , pcb118 = 6
    , pcb138_158 = 7
    , pcb146 = 8
    , pcb153 = 9
    , pcb156 = 10
    , pcb167 = 11
    , pcb170 = 12
    , pcb178 = 13
    , pcb183 = 14
    , pcb187 = 15
    , pcb180 = 16
    , pcb189 = 17
    , pcb194 = 18
    , pcb196_203 = 19
    , pcb199 = 20
    , pcb206 = 21
    , pcb209 = 22
    , BDE17 = 23
    , BDE28 = 24
    , BDE47 = 25 
    , BDE66 = 26
    , BDE85 = 27 
    , BDE99 = 28 
    , BDE100 = 29
    , BDE153 = 30
    , BDE154 = 31
    , BDE183 = 32
    , BDE209 = 33
    , MECPP = 34
    , MEHHP = 35
    , MEOHP = 36
    , MCPP = 37
    , MIBP = 38 
    , MBP = 39 
    , MBZP = 40
    , MEP = 41
    , MEHP = 42
    , dcp_24 = 43
    , dcp_25 = 44
    , b_pb = 45
    , bp_3 = 46
    , m_pb = 47
    , p_pb = 48
    , tcs = 49
    , bpa = 50)

cormat <- round(cor(chem_dist, use = "complete.obs"),2)

melted_cormat <- melt(cormat) %>% rename(Correlation = value)

labelled <- melted_cormat %>% mutate(Class1 = ifelse(str_detect(Var1, "BDE"), "PBDEs",
                                                     ifelse(str_detect(Var1, "^M"), "Phthalates",
                                                            ifelse(str_detect(Var1, "pcb"), "PCBs",
                                                                   "Phenols")))) %>%
  mutate(Class2 = ifelse(str_detect(Var2, "BDE"), "PBDEs",
                         ifelse(str_detect(Var2, "^M"), "Phthalates",
                                ifelse(str_detect(Var2, "pcb"), "PCBs",
                                       "Phenols")))) %>%
  mutate(Class2 = factor(Class2, levels = c("Phthalates", "Phenols",
                                            "PCBs", "PBDEs")))

ggplot(data = labelled, aes(x = Var1, y = Var2)) +
  geom_tile(aes(fill = Correlation), colour = "white") +
  scale_fill_gradient2(low = "#00BFC4", mid = "white", high = "#F8766D",
                       midpoint = 0,
                       na.value = "transparent", limits = c(-1, 1)) +
  theme_grey() + labs(x = "", y = "") +
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_discrete(expand = c(0, 0)) +
  theme(axis.text.x = element_blank(),
        panel.spacing = unit(0, "lines"),
        strip.background = element_blank(),
        strip.placement = "outside", legend.position = "bottom")
```

### Bayesian NMF

#### Loadings

```{r}
eh1 <- readMat("./Data/eh1.mat")[[1]]
```

```{r}
eh1 %>% as_tibble() %>% 
  mutate(Pattern = 1:4) %>% select(Pattern, everything()) %>% 
  gather(key = Chemicals, value = Loadings, -Pattern) %>%
  mutate(Chemicals = fct_inorder(Chemicals)) %>% 
  ggplot(aes(x = Chemicals, y = Loadings)) + geom_col() +
  facet_wrap(.~Pattern) + theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "bottom",
        strip.background = element_blank())
```

##### Relative Error
```{r}
eh1_pcb <- eh1[3,]/max(eh1[3,])
eh1_pbde <- eh1[2,]/max(eh1[2,])
eh1_pht <- eh1[1,]/max(eh1[1,])
eh1_pnl <- eh1[4,]/max(eh1[4,])

sqrt(sum((eh1_pcb - patterns_dist[1,])^2))/sqrt(sum((patterns_dist[1,])^2))
sqrt(sum((eh1_pbde - patterns_dist[2,])^2))/sqrt(sum((patterns_dist[2,])^2))
sqrt(sum((eh1_pht - patterns_dist[4,])^2))/sqrt(sum((patterns_dist[4,])^2))
sqrt(sum((eh1_pnl - patterns_dist[3,])^2))/sqrt(sum((patterns_dist[3,])^2))
```

#### Scores

```{r}
ewa1 <- readMat("./Data/ewa1.mat")[[1]]

dim(ewa1)
```

##### Relative Error
```{r}
# Put on same range
ewa1_pcb <- ewa1[,3]/max(ewa1[,3])
ewa1_pbde <- ewa1[,2]/max(ewa1[,2])
ewa1_pht <- ewa1[,1]/max(ewa1[,1])
ewa1_pnl <- ewa1[,4]/max(ewa1[,4])

max(scores_dist)
max(ewa1)

# Put on same range
score_pcb <- scores_dist[,1]/max(scores_dist[,1])
score_pbde <- scores_dist[,2]/max(scores_dist[,2])
score_pht <- scores_dist[,4]/max(scores_dist[,4])
score_pnl <- scores_dist[,3]/max(scores_dist[,3])

sqrt(sum((ewa1_pcb - score_pcb)^2))/sqrt(sum((score_pcb)^2))
sqrt(sum((ewa1_pbde - score_pbde)^2))/sqrt(sum((score_pbde)^2))
sqrt(sum((ewa1_pht - score_pht)^2))/sqrt(sum((score_pht)^2))
sqrt(sum((ewa1_pnl - score_pnl)^2))/sqrt(sum((score_pnl)^2))
```

## 2: Overlapping Patterns

### Simulate Patterns

Pattern matrix is 4*50, patterns by chemicals.

```{r}
## Construct a matrix for 4 TRUE exposure patterns
patterns_over <- rbind(c(rep(1, 22), rep(0.25, 11), rep(0, 17)),
            c(rep(0.25,22), rep(1, 11), rep(0, 17)),
            c(rep(0, 33), rep(1, 9), rep(0.25, 8)),
            c(rep(0, 33), rep(0.25, 9), rep(1, 8)))
```

```{r}
patterns_over %>% as_tibble() %>% 
  mutate(Pattern = 1:4) %>% select(Pattern, everything()) %>% 
  gather(key = Chemicals, value = Loadings, -Pattern) %>% 
  mutate(Chemicals = fct_inorder(Chemicals)) %>% 
  ggplot(aes(x = Chemicals, y = Loadings)) + geom_col() +
  facet_wrap(.~Pattern) + theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "bottom",
        strip.background = element_blank())
```

### Simulate Individual Scores

Generate random scores indicating the presence of each vector for each observation from a gamma distribution.

```{r}
scores_over <- matrix(nrow = 1000, ncol = 4)

set.seed(1988)
for (i in 1:nrow(scores_over)) {
  scores_over[i,] <- rgamma(4, shape = 1) # gamma dist are INDEPENDENT
}

head(scores_over)
cor(scores_over)
```

### Simulate Chemical Exposures

Multiple scores and vectors, and add to get the mixture.

```{r}
chem_over <- scores_over %*% patterns_over
```

### Simulate Noise

Noise is harder - if your scores are big enough just use a normal distribution to make sure things “work” and we can fancy it up from there.

```{r}
set.seed(1988)
chem_over <- pmax(chem_over + rmatrix(chem_over, dist=rnorm, mean=noise$mean, sd=noise$sd), 0)	
head(chem_over[,1:10])
```  

### Visualize

```{r, echo = FALSE, fig.height = 7}
chem_over <- chem_over %>% 
  as_tibble(.) %>% 
  rename(pcb28 = 1
    , pcb66 = 2
    , pcb74 = 3
    , pcb99 = 4
    , pcb105 = 5
    , pcb118 = 6
    , pcb138_158 = 7
    , pcb146 = 8
    , pcb153 = 9
    , pcb156 = 10
    , pcb167 = 11
    , pcb170 = 12
    , pcb178 = 13
    , pcb183 = 14
    , pcb187 = 15
    , pcb180 = 16
    , pcb189 = 17
    , pcb194 = 18
    , pcb196_203 = 19
    , pcb199 = 20
    , pcb206 = 21
    , pcb209 = 22
    , BDE17 = 23
    , BDE28 = 24
    , BDE47 = 25 
    , BDE66 = 26
    , BDE85 = 27 
    , BDE99 = 28 
    , BDE100 = 29
    , BDE153 = 30
    , BDE154 = 31
    , BDE183 = 32
    , BDE209 = 33
    , MECPP = 34
    , MEHHP = 35
    , MEOHP = 36
    , MCPP = 37
    , MIBP = 38 
    , MBP = 39 
    , MBZP = 40
    , MEP = 41
    , MEHP = 42
    , dcp_24 = 43
    , dcp_25 = 44
    , b_pb = 45
    , bp_3 = 46
    , m_pb = 47
    , p_pb = 48
    , tcs = 49
    , bpa = 50)

cormat_o <- round(cor(chem_over, use = "complete.obs"),2)

melted_cormat_o <- melt(cormat_o) %>% rename(Correlation = value)

labelled_o <- melted_cormat_o %>% mutate(Class1 = ifelse(str_detect(Var1, "BDE"), "PBDEs",
                                                     ifelse(str_detect(Var1, "^M"), "Phthalates",
                                                            ifelse(str_detect(Var1, "pcb"), "PCBs",
                                                                   "Phenols")))) %>%
  mutate(Class2 = ifelse(str_detect(Var2, "BDE"), "PBDEs",
                         ifelse(str_detect(Var2, "^M"), "Phthalates",
                                ifelse(str_detect(Var2, "pcb"), "PCBs",
                                       "Phenols")))) %>%
  mutate(Class2 = factor(Class2, levels = c("Phthalates", "Phenols",
                                            "PCBs", "PBDEs")))

ggplot(data = labelled_o, aes(x = Var1, y = Var2)) +
  geom_tile(aes(fill = Correlation), colour = "white") +
  scale_fill_gradient2(low = "#00BFC4", mid = "white", high = "#F8766D",
                       midpoint = 0,
                       na.value = "transparent", limits = c(-1, 1)) +
  theme_grey() + labs(x = "", y = "") +
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_discrete(expand = c(0, 0)) +
  theme(axis.text.x = element_blank(),
        panel.spacing = unit(0, "lines"),
        strip.background = element_blank(),
        strip.placement = "outside", legend.position = "bottom")
```

### Bayesian NMF

#### Loadings

```{r}
eh2 <- readMat("./Data/eh2.mat")[[1]]
```

```{r}
eh2 %>% as_tibble() %>% 
  mutate(Pattern = 1:4) %>% select(Pattern, everything()) %>% 
  gather(key = Chemicals, value = Loadings, -Pattern) %>%
  mutate(Chemicals = fct_inorder(Chemicals)) %>% 
  ggplot(aes(x = Chemicals, y = Loadings)) + geom_col() +
  facet_wrap(.~Pattern) + theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "bottom",
        strip.background = element_blank())
```

##### Relative Error
```{r}
eh2_pcb <- eh2[4,]/max(eh2[4,])
eh2_pbde <- eh2[1,]/max(eh2[1,])
eh2_pht <- eh2[2,]/max(eh2[2,])
eh2_pnl <- eh2[3,]/max(eh2[3,])

sqrt(sum((eh2_pcb - patterns_over[1,])^2))/sqrt(sum((patterns_over[1,])^2))
sqrt(sum((eh2_pbde - patterns_over[2,])^2))/sqrt(sum((patterns_over[2,])^2))
sqrt(sum((eh2_pht - patterns_over[4,])^2))/sqrt(sum((patterns_over[4,])^2))
sqrt(sum((eh2_pnl - patterns_over[3,])^2))/sqrt(sum((patterns_over[3,])^2))
```

#### Scores

```{r}
ewa2 <- readMat("./Data/ewa2.mat")[[1]]

dim(ewa2)
```

##### Relative Error
```{r}
# Put on same range
ewa2_pcb <- ewa2[,4]/max(ewa2[,4])
ewa2_pbde <- ewa2[,1]/max(ewa2[,1])
ewa2_pht <- ewa2[,2]/max(ewa2[,2])
ewa2_pnl <- ewa2[,3]/max(ewa2[,3])

max(scores_over)
max(ewa2)

# Put on same range
score_pcb <- scores_over[,1]/max(scores_over[,1])
score_pbde <- scores_over[,2]/max(scores_over[,2])
score_pht <- scores_over[,4]/max(scores_over[,4])
score_pnl <- scores_over[,3]/max(scores_over[,3])

sqrt(sum((ewa2_pcb - score_pcb)^2))/sqrt(sum((score_pcb)^2))
sqrt(sum((ewa2_pbde - score_pbde)^2))/sqrt(sum((score_pbde)^2))
sqrt(sum((ewa2_pht - score_pht)^2))/sqrt(sum((score_pht)^2))
sqrt(sum((ewa2_pnl - score_pnl)^2))/sqrt(sum((score_pnl)^2))
```

## 3: Overlapping Patterns & Correlated Scores

### Simulate Patterns

Pattern matrix is 4*50, patterns by chemicals.

```{r}
## Construct a matrix for 4 TRUE exposure patterns
patterns_cor <- rbind(c(rep(1, 22), rep(0.25, 11), rep(0, 17)),
            c(rep(0.25,22), rep(1, 11), rep(0, 17)),
            c(rep(0, 33), rep(1, 9), rep(0.25, 8)),
            c(rep(0, 33), rep(0.25, 9), rep(1, 8)))
```

```{r}
patterns_cor %>% as_tibble() %>% 
  mutate(Pattern = 1:4) %>% select(Pattern, everything()) %>% 
  gather(key = Chemicals, value = Loadings, -Pattern) %>% 
  mutate(Chemicals = fct_inorder(Chemicals)) %>% 
  ggplot(aes(x = Chemicals, y = Loadings)) + geom_col() +
  facet_wrap(.~Pattern) + theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "bottom",
        strip.background = element_blank())
```

### Simulate Individual Scores

Generate random scores indicating the presence of each vector for each observation from a multivariate log normal distribution.

**Try Wishart**

Scores are 1000*4, individuals by patterns.

```{r}
hist(rlnorm(50, meanlog = 1, sdlog = 1))

scores_cor <- matrix(nrow = 1000, ncol = 4)

stdevs <- c(1,1,1,1)
# stdevs is the vector that contains the standard deviations of your patterns

cors <- matrix( c(1,    0.25, 0.15, 0.15,
                  0.25, 1,    0.15, 0.15,
                  0.15, 0.15, 1,    0.25,
                  0.15, 0.15, 0.25, 1), nrow = 4)

b <- stdevs %*% t(stdevs)  
# b is an n*n matrix whose generic term is stdev[i]*stdev[j] (n is number of variables)

covariance <- b * cors  # covariance matrix
# corr = cov / std1*std2, here stdev = 1

set.seed(1988)
scores_cor <- exp(mvrnorm(n = 1000, mu = rep(1, 4), 
                          Sigma = covariance)) # dists are kind of DEPENDENT

head(scores_cor)
cor(scores_cor)
```

### Simulate Chemical Exposures

Multiple scores and vectors, and add to get the mixture

```{r}
chem_cor <- scores_cor %*% patterns_cor
```

### Simulate Noise

Noise is harder - if your scores are big enough just use a normal distribution to make sure things “work” and we can fancy it up from there

```{r}
set.seed(1988)
chem_cor <- pmax(chem_cor + rmatrix(chem_cor, dist=rnorm, mean=noise$mean, sd=noise$sd), 0)	
```  

### Visualize

```{r, echo = FALSE, fig.height = 7}
chem_cor <- chem_cor %>% 
  as_tibble(.) %>% 
  rename(pcb28 = 1
    , pcb66 = 2
    , pcb74 = 3
    , pcb99 = 4
    , pcb105 = 5
    , pcb118 = 6
    , pcb138_158 = 7
    , pcb146 = 8
    , pcb153 = 9
    , pcb156 = 10
    , pcb167 = 11
    , pcb170 = 12
    , pcb178 = 13
    , pcb183 = 14
    , pcb187 = 15
    , pcb180 = 16
    , pcb189 = 17
    , pcb194 = 18
    , pcb196_203 = 19
    , pcb199 = 20
    , pcb206 = 21
    , pcb209 = 22
    , BDE17 = 23
    , BDE28 = 24
    , BDE47 = 25 
    , BDE66 = 26
    , BDE85 = 27 
    , BDE99 = 28 
    , BDE100 = 29
    , BDE153 = 30
    , BDE154 = 31
    , BDE183 = 32
    , BDE209 = 33
    , MECPP = 34
    , MEHHP = 35
    , MEOHP = 36
    , MCPP = 37
    , MIBP = 38 
    , MBP = 39 
    , MBZP = 40
    , MEP = 41
    , MEHP = 42
    , dcp_24 = 43
    , dcp_25 = 44
    , b_pb = 45
    , bp_3 = 46
    , m_pb = 47
    , p_pb = 48
    , tcs = 49
    , bpa = 50)

cormat_cor <- round(cor(chem_cor, use = "complete.obs"),2)

melted_cormat_cor <- melt(cormat_cor) %>% rename(Correlation = value)

labelled_cor <- melted_cormat_cor %>% mutate(Class1 = ifelse(str_detect(Var1, "BDE"), "PBDEs",
                                                     ifelse(str_detect(Var1, "^M"), "Phthalates",
                                                            ifelse(str_detect(Var1, "pcb"), "PCBs",
                                                                   "Phenols")))) %>%
  mutate(Class2 = ifelse(str_detect(Var2, "BDE"), "PBDEs",
                         ifelse(str_detect(Var2, "^M"), "Phthalates",
                                ifelse(str_detect(Var2, "pcb"), "PCBs",
                                       "Phenols")))) %>%
  mutate(Class2 = factor(Class2, levels = c("Phthalates", "Phenols",
                                            "PCBs", "PBDEs")))

ggplot(data = labelled_cor, aes(x = Var1, y = Var2)) +
  geom_tile(aes(fill = Correlation), colour = "white") +
  scale_fill_gradient2(low = "#00BFC4", mid = "white", high = "#F8766D",
                       midpoint = 0,
                       na.value = "transparent", limits = c(-1, 1)) +
  theme_grey() + labs(x = "", y = "") +
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_discrete(expand = c(0, 0)) +
  theme(axis.text.x = element_blank(),
        panel.spacing = unit(0, "lines"),
        strip.background = element_blank(),
        strip.placement = "outside", legend.position = "bottom")
```

### Bayesian NMF

#### Loadings

```{r}
eh3 <- readMat("./Data/eh3.mat")[[1]]
```

```{r}
eh3 %>% as_tibble() %>% 
  mutate(Pattern = 1:5) %>% select(Pattern, everything()) %>% 
  gather(key = Chemicals, value = Loadings, -Pattern) %>%
  mutate(Chemicals = fct_inorder(Chemicals)) %>% 
  ggplot(aes(x = Chemicals, y = Loadings)) + geom_col() +
  facet_wrap(.~Pattern) + theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "bottom",
        strip.background = element_blank())
```

##### Relative Error
```{r}
eh3_pcb <- eh3[2,]/max(eh3[2,])
eh3_pbde <- eh3[4,]/max(eh3[4,])
eh3_pht <- eh3[1,]/max(eh3[1,])
eh3_pnl <- eh3[3,]/max(eh3[3,])

sqrt(sum((eh3_pcb - patterns_cor[1,])^2))/sqrt(sum((patterns_cor[1,])^2))
sqrt(sum((eh3_pbde - patterns_cor[2,])^2))/sqrt(sum((patterns_cor[2,])^2))
sqrt(sum((eh3_pht - patterns_cor[4,])^2))/sqrt(sum((patterns_cor[4,])^2))
sqrt(sum((eh3_pnl - patterns_cor[3,])^2))/sqrt(sum((patterns_cor[3,])^2))

sqrt(sum((eh3[5,])^2))
```

#### Scores

```{r}
ewa3 <- readMat("./Data/ewa3.mat")[[1]]

dim(ewa3)
```

##### Relative Error
```{r}
# Put on same range
ewa3_pcb <- ewa3[,2]/max(ewa3[,2])
ewa3_pbde <- ewa3[,4]/max(ewa3[,4])
ewa3_pht <- ewa3[,1]/max(ewa3[,1])
ewa3_pnl <- ewa3[,3]/max(ewa3[,3])

max(scores_cor)
max(ewa3)

# Put on same range
score_pcb <- scores_cor[,1]/max(scores_cor[,1])
score_pbde <- scores_cor[,2]/max(scores_cor[,2])
score_pht <- scores_cor[,4]/max(scores_cor[,4])
score_pnl <- scores_cor[,3]/max(scores_cor[,3])

sqrt(sum((ewa3_pcb - score_pcb)^2))/sqrt(sum((score_pcb)^2))
sqrt(sum((ewa3_pbde - score_pbde)^2))/sqrt(sum((score_pbde)^2))
sqrt(sum((ewa3_pht - score_pht)^2))/sqrt(sum((score_pht)^2))
sqrt(sum((ewa3_pnl - score_pnl)^2))/sqrt(sum((score_pnl)^2))

sqrt(sum((ewa3[,5])^2))
```
