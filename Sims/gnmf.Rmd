---
title: "NMF & Sim Data"
author: "Lizzy Gibson"
date: "2/18/2020"
output: 
  html_document:
    toc: TRUE
    toc_float: TRUE
---

```{r setup, include=FALSE}
options(scipen = 999)
library(MNdata) # my data
library(reshape2) # melt
library(gridExtra) # gridarrange
library(bindata) # multivariate binomial dist
library(NMF) # rmatrix
library(MASS) # mvrnorm
library(tidyverse)
library(R.matlab)
```

Simulate dataset with 1000 individuals and 50 chemicals to approx DATA GENERATING PROCESS of Mothers and Newborns cohort data.

* 22 pcbs, 11 pbdes, 9 phthalates, 8 phenols

<div class = "row">
  
<div class = "col-md-3">
* PCBs (22):
    * pcb28
    * pcb66
    * pcb74
    * pcb99
    * pcb105
    * pcb118
    * pcb138_158
    * pcb146
    * pcb153
    * pcb156
    * pcb167
    * pcb170
    * pcb178
    * pcb183
    * pcb187
    * pcb180
    * pcb189
    * pcb194
    * pcb196_203
    * pcb199
    * pcb206
    * pcb209
</div>
  
<div class = "col-md-3">
* PBDEs (11):
    * BDE17
    * BDE28
    * BDE47
    * BDE66
    * BDE85
    * BDE99
    * BDE100
    * BDE153
    * BDE154
    * BDE183
    * BDE209
</div>
  
<div class = "col-md-3">
* Phthalates (9):
    * MECPP
    * MEHHP
    * MEOHP
    * MCPP
    * MIBP
    * MBP
    * MBZP
    * MEP
    * MEHP
* Phenols (8):
    * dcp_24
    * dcp_25
    * b_pb
    * bp_3
    * m_pb
    * p_pb
    * tcs
    * bpa
</div>
</div>

## 1: Distinct Patterns

### Simulate Patterns

Generate 4 non-negative vectors of length 50 “by hand” — vectors should be overlapping a bit, and at this stage don’t have to look too much like pollution. just make 20 (of 50) elements 1 and the rest 0.

Pattern matrix is 4*50, patterns by chemicals.

```{r}
## Construct a matrix for 4 TRUE exposure patterns
labels <-  c("pcb28", "pcb66", "pcb74", "pcb99", "pcb105", "pcb118", "pcb138_158", "pcb146", "pcb153", "pcb156", "pcb167",
          "pcb170", "pcb178", "pcb183", "pcb187", "pcb180", "pcb189", "pcb194", "pcb196_203", "pcb199", "pcb206", "pcb209",
          "BDE17", "BDE28", "BDE47", "BDE66", "BDE85", "BDE99", "BDE100", "BDE153", "BDE154", "BDE183", "BDE209", "MECPP",
          "MEHHP", "MEOHP", "MCPP", "MIBP", "MBP", "MBZP", "MEP", "MEHP", "dcp_24", "dcp_25", "b_pb", "bp_3", "m_pb",
          "p_pb", "tcs", "bpa")

patterns_dist <- rbind(c(rep(1, 22), rep(0, 28)),
                       c(rep(0, 22), rep(1, 11), rep(0, 17)),
                       c(rep(0, 33), rep(1, 9), rep(0, 8)),
                       c(rep(0, 42), rep(1, 8)))
```

```{r}
colnames(patterns_dist) <- labels

patterns_dist %>% as_tibble() %>% 
  mutate(Pattern = 1:4) %>% select(Pattern, everything()) %>% 
  gather(key = Chemicals, value = Loadings, -Pattern) %>%
  mutate(Chemicals = fct_inorder(Chemicals)) %>% 
  mutate(Group = ifelse(str_detect(Chemicals, "BDE"), "PBDEs",
                                                     ifelse(str_detect(Chemicals, "^M"), "Phthalates",
                                                            ifelse(str_detect(Chemicals, "pcb"), "PCBs",
                                                                   "Phenols")))) %>% 
  ggplot(aes(x = Chemicals, y = Loadings)) + geom_col(aes(fill = Group)) +
  facet_wrap(.~Pattern) + theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "bottom",
        strip.background = element_blank())
```

### Simulate Scores

Generate random scores indicating the presence of each vector for each observation from a gamma distribution.

```{r}
hist(rgamma(500, shape = 1))

scores_dist <- matrix(nrow = 1000, ncol = 4)

set.seed(1988)
for (i in 1:nrow(scores_dist)) {
  scores_dist[i,] <- rgamma(4, shape = 1) # gamma dist are INDEPENDENT
}

head(scores_dist)
cor(scores_dist)
```

### Simulate Chemical Exposures

Multiple scores and vectors, and add to get the mixture.

```{r}
chem_dist <- scores_dist %*% patterns_dist
```

### Simulate Noise

Noise is harder - if your scores are big enough just use a normal distribution to make sure things “work” and we can fancy it up from there.

```{r}
noise <- list(mean=0, sd=1)
set.seed(1988)
chem_dist <- pmax(chem_dist + rmatrix(chem_dist, dist=rnorm, mean=noise$mean, sd=noise$sd), 0)	
head(chem_dist[,1:10])
```  

### Visualize

```{r, echo = FALSE, fig.height = 7}
chem_dist <- chem_dist %>% 
  as_tibble(.)

cormat <- round(cor(chem_dist, use = "complete.obs"),2)

melted_cormat <- melt(cormat) %>% rename(Correlation = value)

labelled <- melted_cormat %>% mutate(Class1 = ifelse(str_detect(Var1, "BDE"), "PBDEs",
                                                     ifelse(str_detect(Var1, "^M"), "Phthalates",
                                                            ifelse(str_detect(Var1, "pcb"), "PCBs",
                                                                   "Phenols")))) %>%
  mutate(Class2 = ifelse(str_detect(Var2, "BDE"), "PBDEs",
                         ifelse(str_detect(Var2, "^M"), "Phthalates",
                                ifelse(str_detect(Var2, "pcb"), "PCBs",
                                       "Phenols")))) %>%
  mutate(Class2 = factor(Class2, levels = c("Phthalates", "Phenols",
                                            "PCBs", "PBDEs")))

ggplot(data = labelled, aes(x = Var1, y = Var2)) +
  geom_tile(aes(fill = Correlation), colour = "white") +
  scale_fill_gradient2(low = "#00BFC4", mid = "white", high = "#F8766D",
                       midpoint = 0,
                       na.value = "transparent", limits = c(-1, 1)) +
  theme_grey() + labs(x = "", y = "") +
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_discrete(expand = c(0, 0)) +
  theme(axis.text.x = element_blank(),
        panel.spacing = unit(0, "lines"),
        strip.background = element_blank(),
        strip.placement = "outside", legend.position = "bottom")
```

### Bayesian NMF Solution

#### Loadings

```{r}
eh1 <- readMat(here::here("./Data/eh1.mat"))[[1]]
```

```{r}
colnames(eh1) <- labels

eh1 %>% as_tibble() %>% 
  mutate(Pattern = 1:4) %>% select(Pattern, everything()) %>% 
  gather(key = Chemicals, value = Loadings, -Pattern) %>%
  mutate(Chemicals = fct_inorder(Chemicals)) %>% 
  mutate(Group = ifelse(str_detect(Chemicals, "BDE"), "PBDEs",
                                                     ifelse(str_detect(Chemicals, "^M"), "Phthalates",
                                                            ifelse(str_detect(Chemicals, "pcb"), "PCBs",
                                                                   "Phenols")))) %>% 
  ggplot(aes(x = Chemicals, y = Loadings)) + geom_col(aes(fill = Group)) +
  facet_wrap(.~Pattern) + theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "bottom",
        strip.background = element_blank())
```

##### Relative Error
```{r}
eh1_pcb <- eh1[3,]/max(eh1[3,])
eh1_pbde <- eh1[2,]/max(eh1[2,])
eh1_pnl <- eh1[1,]/max(eh1[1,])
eh1_pht <- eh1[4,]/max(eh1[4,])

sqrt(sum((eh1_pcb - patterns_dist[1,])^2))/sqrt(sum((patterns_dist[1,])^2))
sqrt(sum((eh1_pbde - patterns_dist[2,])^2))/sqrt(sum((patterns_dist[2,])^2))
sqrt(sum((eh1_pht - patterns_dist[3,])^2))/sqrt(sum((patterns_dist[3,])^2))
sqrt(sum((eh1_pnl - patterns_dist[4,])^2))/sqrt(sum((patterns_dist[4,])^2))
```

#### Scores

```{r}
ewa1 <- readMat(here::here("./Data/ewa1.mat"))[[1]]

dim(ewa1)
```

##### Relative Error
```{r}
# Put on same range
ewa1_pcb <- ewa1[,3]/max(ewa1[,3])
ewa1_pbde <- ewa1[,2]/max(ewa1[,2])
ewa1_pht <- ewa1[,4]/max(ewa1[,4])
ewa1_pnl <- ewa1[,1]/max(ewa1[,1])

max(scores_dist)
max(ewa1)

# Put on same range
score_pcb1 <- scores_dist[,1]/max(scores_dist[,1])
score_pbde1 <- scores_dist[,2]/max(scores_dist[,2])
score_pnl1 <- scores_dist[,4]/max(scores_dist[,4])
score_pht1 <- scores_dist[,3]/max(scores_dist[,3])

sqrt(sum((ewa1_pcb - score_pcb1)^2))/sqrt(sum((score_pcb1)^2))
sqrt(sum((ewa1_pbde - score_pbde1)^2))/sqrt(sum((score_pbde1)^2))
sqrt(sum((ewa1_pht - score_pht1)^2))/sqrt(sum((score_pht1)^2))
sqrt(sum((ewa1_pnl - score_pnl1)^2))/sqrt(sum((score_pnl1)^2))
```

## 2: Overlapping Patterns

### Simulate Patterns

Pattern matrix is 4*50, patterns by chemicals.

```{r}
## Construct a matrix for 4 TRUE exposure patterns
patterns_over <- rbind(c(rep(1, 22), rep(0.25, 11), rep(0, 17)),
            c(rep(0.25,22), rep(1, 11), rep(0, 17)),
            c(rep(0, 33), rep(1, 9), rep(0.25, 8)),
            c(rep(0, 33), rep(0.25, 9), rep(1, 8)))
```

```{r}
colnames(patterns_over) <- labels

patterns_over %>% as_tibble() %>% 
  mutate(Pattern = 1:4) %>% select(Pattern, everything()) %>% 
  gather(key = Chemicals, value = Loadings, -Pattern) %>% 
  mutate(Chemicals = fct_inorder(Chemicals)) %>%
  mutate(Group = ifelse(str_detect(Chemicals, "BDE"), "PBDEs",
                                                     ifelse(str_detect(Chemicals, "^M"), "Phthalates",
                                                            ifelse(str_detect(Chemicals, "pcb"), "PCBs",
                                                                   "Phenols")))) %>% 
  ggplot(aes(x = Chemicals, y = Loadings)) + geom_col(aes(fill = Group)) +
  facet_wrap(.~Pattern) + theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "bottom",
        strip.background = element_blank())
```

### Simulate Scores

Generate random scores indicating the presence of each vector for each observation from a gamma distribution.

```{r}
scores_over <- matrix(nrow = 1000, ncol = 4)

set.seed(1988)
for (i in 1:nrow(scores_over)) {
  scores_over[i,] <- rgamma(4, shape = 1) # gamma dist are INDEPENDENT
}

head(scores_over)
cor(scores_over)
```

### Simulate Chemical Exposures

Multiple scores and vectors, and add to get the mixture.

```{r}
chem_over <- scores_over %*% patterns_over
```

### Simulate Noise

Noise is harder - if your scores are big enough just use a normal distribution to make sure things “work” and we can fancy it up from there.

```{r}
set.seed(1988)
chem_over <- pmax(chem_over + rmatrix(chem_over, dist=rnorm, mean=noise$mean, sd=noise$sd), 0)	
head(chem_over[,1:10])
```  

### Visualize

```{r, fig.height = 7}
chem_over <- chem_over %>% 
  as_tibble(.)

cormat_o <- round(cor(chem_over, use = "complete.obs"),2)

melted_cormat_o <- melt(cormat_o) %>% rename(Correlation = value)

labelled_o <- melted_cormat_o %>% mutate(Class1 = ifelse(str_detect(Var1, "BDE"), "PBDEs",
                                                     ifelse(str_detect(Var1, "^M"), "Phthalates",
                                                            ifelse(str_detect(Var1, "pcb"), "PCBs",
                                                                   "Phenols")))) %>%
  mutate(Class2 = ifelse(str_detect(Var2, "BDE"), "PBDEs",
                         ifelse(str_detect(Var2, "^M"), "Phthalates",
                                ifelse(str_detect(Var2, "pcb"), "PCBs",
                                       "Phenols")))) %>%
  mutate(Class2 = factor(Class2, levels = c("Phthalates", "Phenols",
                                            "PCBs", "PBDEs")))

ggplot(data = labelled_o, aes(x = Var1, y = Var2)) +
  geom_tile(aes(fill = Correlation), colour = "white") +
  scale_fill_gradient2(low = "#00BFC4", mid = "white", high = "#F8766D",
                       midpoint = 0,
                       na.value = "transparent", limits = c(-1, 1)) +
  theme_grey() + labs(x = "", y = "") +
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_discrete(expand = c(0, 0)) +
  theme(axis.text.x = element_blank(),
        panel.spacing = unit(0, "lines"),
        strip.background = element_blank(),
        strip.placement = "outside", legend.position = "bottom")
```

### Bayesian NMF Solution

#### Loadings

```{r}
eh2 <- readMat(here::here("./Data/eh2.mat"))[[1]]
```

```{r}
colnames(eh2) <- labels

eh2 %>% as_tibble() %>% 
  mutate(Pattern = 1:4) %>% select(Pattern, everything()) %>% 
  gather(key = Chemicals, value = Loadings, -Pattern) %>%
  mutate(Chemicals = fct_inorder(Chemicals)) %>% 
  mutate(Group = ifelse(str_detect(Chemicals, "BDE"), "PBDEs",
                                                     ifelse(str_detect(Chemicals, "^M"), "Phthalates",
                                                            ifelse(str_detect(Chemicals, "pcb"), "PCBs",
                                                                   "Phenols")))) %>% 
  ggplot(aes(x = Chemicals, y = Loadings)) + geom_col(aes(fill = Group)) +
  facet_wrap(.~Pattern) + theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "bottom",
        strip.background = element_blank())
```

##### Relative Error
```{r}
eh2_pcb <- eh2[4,]/max(eh2[4,])
eh2_pbde <- eh2[1,]/max(eh2[1,])
eh2_pht <- eh2[3,]/max(eh2[3,])
eh2_pnl <- eh2[2,]/max(eh2[2,])

sqrt(sum((eh2_pcb - patterns_over[1,])^2))/sqrt(sum((patterns_over[1,])^2))
sqrt(sum((eh2_pbde - patterns_over[2,])^2))/sqrt(sum((patterns_over[2,])^2))
sqrt(sum((eh2_pnl - patterns_over[4,])^2))/sqrt(sum((patterns_over[4,])^2))
sqrt(sum((eh2_pht - patterns_over[3,])^2))/sqrt(sum((patterns_over[3,])^2))
```

#### Scores

```{r}
ewa2 <- readMat(here::here("./Data/ewa2.mat"))[[1]]

dim(ewa2)
```

##### Relative Error
```{r}
# Put on same range
ewa2_pcb <- ewa2[,4]/max(ewa2[,4])
ewa2_pbde <- ewa2[,1]/max(ewa2[,1])
ewa2_pnl <- ewa2[,2]/max(ewa2[,2])
ewa2_pht <- ewa2[,3]/max(ewa2[,3])

max(scores_over)
max(ewa2)

# Put on same range
score_pcb2 <- scores_over[,1]/max(scores_over[,1])
score_pbde2 <- scores_over[,2]/max(scores_over[,2])
score_pht2 <- scores_over[,3]/max(scores_over[,3])
score_pnl2 <- scores_over[,4]/max(scores_over[,4])

sqrt(sum((ewa2_pcb - score_pcb2)^2))/sqrt(sum((score_pcb2)^2))
sqrt(sum((ewa2_pbde - score_pbde2)^2))/sqrt(sum((score_pbde2)^2))
sqrt(sum((ewa2_pht - score_pht2)^2))/sqrt(sum((score_pht2)^2))
sqrt(sum((ewa2_pnl - score_pnl2)^2))/sqrt(sum((score_pnl2)^2))
```

## 3: Correlated Scores

### Simulate Patterns

Pattern matrix is 4*50, patterns by chemicals.

```{r}
## Construct a matrix for 4 TRUE exposure patterns
set.seed(10)
patterns_cor <- rbind(c(runif(22, 0, 1), runif(11, 0, 0.15), runif(17, 0, 0.15)),
                      c(runif(22, 0, 0.15), runif(11, 0, 1), runif(17, 0, 0.15)),
                      c(runif(33, 0, 0.15), runif(9, 0, 1), runif(8, 0, 0.15)),
                      c(runif(33, 0, 0.15), runif(9, 0, 0.15), runif(8, 0, 1)))

head(cor(patterns_cor[,1:10]))
```

```{r}
colnames(patterns_cor) <- labels

patterns_cor %>% as_tibble() %>% 
  mutate(Pattern = 1:4) %>% select(Pattern, everything()) %>% 
  gather(key = Chemicals, value = Loadings, -Pattern) %>% 
  mutate(Chemicals = fct_inorder(Chemicals)) %>% 
  mutate(Group = ifelse(str_detect(Chemicals, "BDE"), "PBDEs",
                                                     ifelse(str_detect(Chemicals, "^M"), "Phthalates",
                                                            ifelse(str_detect(Chemicals, "pcb"), "PCBs",
                                                                   "Phenols")))) %>% 
  ggplot(aes(x = Chemicals, y = Loadings)) + geom_col(aes(fill = Group)) +
  facet_wrap(.~Pattern) + theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "bottom",
        strip.background = element_blank())
```

### Simulate Scores

Generate random scores indicating the presence of each vector for each observation from a multivariate log normal distribution.

**Try Wishart**

Scores are 1000*4, individuals by patterns.

```{r}
hist(rlnorm(50, meanlog = 1, sdlog = 1))

scores_cor <- matrix(nrow = 1000, ncol = 4)

stdevs <- c(1,1,1,1)
# vector contains the standard deviations of patterns

cors <- matrix( c(1,    0.25, 0.15, 0.15,
                  0.25, 1,    0.15, 0.15,
                  0.15, 0.15, 1,    0.25,
                  0.15, 0.15, 0.25, 1), nrow = 4)

b <- stdevs %*% t(stdevs)  
# b is n*n matrix whose generic term is stdev[i]*stdev[j] (n is number of variables)

covariance <- b * cors  # covariance matrix
# corr = cov / std1*std2, here stdev = 1

set.seed(1988)
scores_cor <- exp(mvrnorm(n = 1000, mu = rep(1, 4), 
                          Sigma = covariance)) # dists are kind of DEPENDENT

head(scores_cor)
cor(scores_cor)
```

### Simulate Chemical Exposures

Multiple scores and vectors, and add to get the mixture

```{r}
chem_cor <- scores_cor %*% patterns_cor
```

### Simulate Noise

Noise is harder - if your scores are big enough just use a normal distribution to make sure things “work” and we can fancy it up from there

```{r}
set.seed(1988)
chem_cor <- pmax(chem_cor + rmatrix(chem_cor, dist=rnorm, mean=noise$mean, sd=noise$sd), 0)	
```  

### Visualize

```{r, fig.height = 7}
chem_cor <- chem_cor %>% 
  as_tibble(.)

cormat_cor <- round(cor(chem_cor, use = "complete.obs"),2)

melted_cormat_cor <- melt(cormat_cor) %>% rename(Correlation = value)

labelled_cor <- melted_cormat_cor %>% mutate(Class1 = ifelse(str_detect(Var1, "BDE"), "PBDEs",
                                                     ifelse(str_detect(Var1, "^M"), "Phthalates",
                                                            ifelse(str_detect(Var1, "pcb"), "PCBs",
                                                                   "Phenols")))) %>%
  mutate(Class2 = ifelse(str_detect(Var2, "BDE"), "PBDEs",
                         ifelse(str_detect(Var2, "^M"), "Phthalates",
                                ifelse(str_detect(Var2, "pcb"), "PCBs",
                                       "Phenols")))) %>%
  mutate(Class2 = factor(Class2, levels = c("Phthalates", "Phenols",
                                            "PCBs", "PBDEs")))

ggplot(data = labelled_cor, aes(x = Var1, y = Var2)) +
  geom_tile(aes(fill = Correlation), colour = "white") +
  scale_fill_gradient2(low = "#00BFC4", mid = "white", high = "#F8766D",
                       midpoint = 0,
                       na.value = "transparent", limits = c(-1, 1)) +
  theme_grey() + labs(x = "", y = "") +
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_discrete(expand = c(0, 0)) +
  theme(axis.text.x = element_blank(),
        panel.spacing = unit(0, "lines"),
        strip.background = element_blank(),
        strip.placement = "outside", legend.position = "bottom")
```

### Bayesian NMF Soultion

#### Loadings

```{r}
eh3 <- readMat(here::here("./Data/eh3.mat"))[[1]]
```

```{r}
colnames(eh3) <- labels

eh3 %>% as_tibble() %>% 
  mutate(Pattern = 1:4) %>% select(Pattern, everything()) %>% 
  gather(key = Chemicals, value = Loadings, -Pattern) %>%
  mutate(Chemicals = fct_inorder(Chemicals)) %>% 
  mutate(Group = ifelse(str_detect(Chemicals, "BDE"), "PBDEs",
                                                     ifelse(str_detect(Chemicals, "^M"), "Phthalates",
                                                            ifelse(str_detect(Chemicals, "pcb"), "PCBs",
                                                                   "Phenols")))) %>% 
  ggplot(aes(x = Chemicals, y = Loadings)) + geom_col(aes(fill = Group)) +
  facet_wrap(.~Pattern) + theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "bottom",
        strip.background = element_blank())
```

##### Relative Error
```{r}
eh3_pcb <- eh3[2,]/max(eh3[2,])
eh3_pbde <- eh3[1,]/max(eh3[1,])
eh3_pht <- eh3[4,]/max(eh3[4,])
eh3_pnl <- eh3[3,]/max(eh3[3,])

sqrt(sum((eh3_pcb - patterns_cor[1,])^2))/sqrt(sum((patterns_cor[1,])^2))
sqrt(sum((eh3_pbde - patterns_cor[2,])^2))/sqrt(sum((patterns_cor[2,])^2))
sqrt(sum((eh3_pht - patterns_cor[3,])^2))/sqrt(sum((patterns_cor[3,])^2))
sqrt(sum((eh3_pnl - patterns_cor[4,])^2))/sqrt(sum((patterns_cor[4,])^2))
```

#### Scores

```{r}
ewa3 <- readMat(here::here("./Data/ewa3.mat"))[[1]]

dim(ewa3)
```

##### Relative Error
```{r}
# Put on same range
ewa3_pcb <- ewa3[,2]/max(ewa3[,2])
ewa3_pbde <- ewa3[,1]/max(ewa3[,1])
ewa3_pht <- ewa3[,4]/max(ewa3[,4])
ewa3_pnl <- ewa3[,3]/max(ewa3[,3])

max(scores_cor)
max(ewa3)

# Put on same range
score_pcb3 <- scores_cor[,1]/max(scores_cor[,1])
score_pbde3 <- scores_cor[,2]/max(scores_cor[,2])
score_pnl3 <- scores_cor[,4]/max(scores_cor[,4])
score_pht3 <- scores_cor[,3]/max(scores_cor[,3])

sqrt(sum((ewa3_pcb - score_pcb3)^2))/sqrt(sum((score_pcb3)^2))
sqrt(sum((ewa3_pbde - score_pbde3)^2))/sqrt(sum((score_pbde3)^2))
sqrt(sum((ewa3_pht - score_pht3)^2))/sqrt(sum((score_pht3)^2))
sqrt(sum((ewa3_pnl - score_pnl3)^2))/sqrt(sum((score_pnl3)^2))
```

